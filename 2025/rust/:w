#![feature(iterator_try_collect)]

fn main() -> anyhow::Result<()> {
    let input = aoc_2025::utils::get_input()?;
    let problems = parsing::parse_input(input.trim())?;

    println!("{}", part1(&problems));
    println!("{}", part2(&problems));

    Ok(())
}

fn part1(problems: &[Problem]) -> u64 {
    problems.iter().map(|p| p.solve_wrong()).sum()
}

fn part2(problems: &[Problem]) -> u64 {
    problems.iter().map(|p| p.solve()).sum()
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Operation {
    Add,
    Multiply,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Problem {
    numbers: Vec<u64>,
    ceph_numbers: Vec<u64>,
    operation: Operation,
}

impl Problem {
    fn solve_wrong(&self) -> u64 {
        self.compute(&self.numbers)
    }

    fn solve(&self) -> u64 {
        self.compute(&self.ceph_numbers)
    }

    fn compute(&self, numbers: &[u64]) -> u64 {
        match self.operation {
            Operation::Add => numbers.iter().sum(),
            Operation::Multiply => numbers.iter().fold(1, |acc, n| acc * n),
        }
    }
}

mod parsing {
    use anyhow::Result;

    use crate::{Operation, Problem};

    pub fn parse_input(s: &str) -> anyhow::Result<Vec<Problem>> {
        let line_width = s.lines().next().map(|line| line.len()).unwrap_or(0);
        let columns = find_columns(s)?;
        let mut problems = vec![];
        for (i, op) in columns {
            todo!();
        }
        Ok(problems)
        // let rows: Vec<_> = s.lines().collect();
        // let number_rows: Vec<Vec<&str>> = rows[..rows.len() - 1]
        //     .iter()
        //     .map(|line| line.split_whitespace().collect::<Vec<_>>())
        //     .collect();
        // let operations = parse_operations(rows[rows.len() - 1])?;
        // let problem_count = number_rows.first().map(|row| row.len()).unwrap_or(0);
        // if number_rows.iter().any(|row| row.len() != problem_count)
        //     || operations.len() != problem_count
        // {
        //     bail!("Failed to parse input: Uneven rows detected");
        // }

        // let mut problems = Vec::with_capacity(problem_count);
        // for i in 0..problem_count {
        //     let numbers = number_rows
        //         .iter()
        //         .map(|row| row[i].parse::<u64>())
        //         .try_collect()?;
        //     let (operation, max_digits) = operations[i];
        //     problems.push(Problem {
        //         numbers,
        //         operation,
        //         max_digits,
        //     });
        // }
        // Ok(problems)
    }

    fn find_columns(s: &str) -> anyhow::Result<Vec<(usize, usize, Operation)>> {
        let line = s
            .lines()
            .last()
            .ok_or_else(|| anyhow::anyhow!("No operation line found"))?;
        let ops: Vec<(usize, Operation)> = line
            .char_indices()
            .filter_map(|(i, c)| match c {
                '*' => Some((i, Operation::Multiply)),
                '+' => Some((i, Operation::Add)),
                ' ' | '\t' => None,
                _ => return Err(anyhow!("Invalid character '{}' at position {}", c, i)),
            })
            .collect::<Result<_>>()?;
    }
}

#[cfg(test)]
mod tests {
    use crate::{parsing, Operation, Problem};

    static TEST_DATA: &str = "\
        123 328  51 64 \n\
         45 64  387 23 \n\
          6 98  215 314\n\
        *   +   *   +  ";

    fn make_problem(numbers: Vec<u64>, ceph_numbers: Vec<u64>, operation: Operation) -> Problem {
        Problem {
            numbers,
            ceph_numbers,
            operation,
        }
    }

    #[test]
    fn parsing() {
        let problems = parsing::parse_input(TEST_DATA).unwrap();
        let expected = vec![
            make_problem(vec![123, 45, 6], vec![1, 24, 356], Operation::Multiply),
            make_problem(vec![328, 64, 98], vec![369, 248, 8], Operation::Add),
            make_problem(vec![51, 387, 215], vec![32, 581, 175], Operation::Multiply),
            make_problem(vec![64, 23, 314], vec![623, 431, 4], Operation::Add),
        ];

        assert_eq!(problems, expected);
    }

    #[test]
    fn solve_wrong() {
        let problems = parsing::parse_input(TEST_DATA).unwrap();
        let solutions: Vec<_> = problems.iter().map(|p| p.solve_wrong()).collect();
        assert_eq!(solutions, vec![33210, 490, 4243455, 401]);
    }

    #[test]
    fn solve() {
        let problems = parsing::parse_input(TEST_DATA).unwrap();
        let solutions: Vec<_> = problems.iter().map(|p| p.solve()).collect();
        assert_eq!(solutions, vec![1058, 325600, 625, 8544]);
    }
}
